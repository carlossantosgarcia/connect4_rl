<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 AI</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Connect 4 vs AI</h1>

        <div class="controls">
            <label for="model-select">Play against:</label>
            <select id="model-select">
                <option value="">-- Select AI Model --</option>
            </select>
            <button id="reset-game">Reset Game</button>
            <button id="player-first-toggle">AI Starts</button>
        </div>
        
        <div id="game-info">
            <p id="status-message">Select a model and start playing!</p>
            <p id="game-stats">Model Games Played: <span id="model-games-played">0</span></p>
        </div>

        <div id="board-container">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
        const ROWS = 6;
        const COLUMNS = 7;
        const CONNECT_N = 4;
        const HUMAN_PLAYER = 1;
        const AI_PLAYER = -1;
        const CELL_SIZE = 80;
        const PIECE_RADIUS_RATIO = 0.8;

        const boardContainer = document.getElementById('board-container');
        const modelSelect = document.getElementById('model-select');
        const statusMessage = document.getElementById('status-message');
        const resetGameButton = document.getElementById('reset-game');
        const modelGamesPlayedSpan = document.getElementById('model-games-played');
        const playerFirstToggle = document.getElementById('player-first-toggle');

        let board = [];
        let currentPlayer;
        let gameActive = false;
        let aiModelSession = null;
        let currentModelFile = null;
        let humanStarts = false;

        const InferenceSession = ort.InferenceSession;

        // Helper function to update status message with appropriate styling
        function updateStatusMessage(message, isPlayerTurn = null) {
            statusMessage.textContent = message;
            statusMessage.className = '';
            if (isPlayerTurn === true) {
                statusMessage.classList.add('your-turn');
            } else if (isPlayerTurn === false) {
                statusMessage.classList.add('ai-turn');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadModelsDropdown();
            setupEventListeners();
            initializeBoardDOM();
            resetGame();
        });

        function setupEventListeners() {
            modelSelect.addEventListener('change', onModelSelected);
            resetGameButton.addEventListener('click', resetGame);
            playerFirstToggle.addEventListener('click', togglePlayerStart);
        }

        function togglePlayerStart() {
            humanStarts = !humanStarts;
            playerFirstToggle.textContent = humanStarts ? "Player Starts" : "AI Starts";
            playerFirstToggle.classList.toggle('active', humanStarts);
            if (aiModelSession) {
                resetGame();
            } else {
                updateStatusMessage(humanStarts ? "Select a model. Player starts." : "Select a model. AI will start.");
            }
        }

        async function loadModelsDropdown() {
            try {
                console.log("Attempting to fetch models.json from: models/models.json");
                const response = await fetch('models/models.json');
                console.log("Fetch response status for models.json:", response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching models.json. URL: ${response.url}`);
                }
                
                const models = await response.json();
                console.log("Successfully parsed models.json:", models);

                if (!Array.isArray(models)) {
                    console.error("models.json did not parse into an array. Parsed data:", models);
                    updateStatusMessage("Error: Model list is not in the correct format.");
                    modelSelect.innerHTML = '<option value="">-- Invalid Model List --</option>';
                    return;
                }
                
                modelSelect.innerHTML = '<option value="">-- Select AI Model --</option>'; 

                if (models.length === 0) {
                    console.warn("models.json is empty. No models to load.");
                    updateStatusMessage("No AI models found in the list.");
                    modelSelect.innerHTML = '<option value="">-- No Models Available --</option>';
                    return;
                }

                models.forEach(model => {
                    if (model && typeof model.file === 'string' && typeof model.name === 'string') {
                        const option = document.createElement('option');
                        option.value = model.file;
                        option.textContent = model.name;
                        modelSelect.appendChild(option);
                    } else {
                        console.warn("Skipping invalid model entry in models.json:", model);
                    }
                });
                console.log("Model dropdown populated.");

            } catch (error) {
                console.error("Failed to load or process models.json:", error);
                updateStatusMessage("Error loading AI models list. Check browser console.");
                modelSelect.innerHTML = '<option value="">-- Error Loading Models --</option>';
            }
        }

        async function onModelSelected() {
            const modelFile = modelSelect.value;
            if (!modelFile) {
                aiModelSession = null;
                currentModelFile = null;
                updateStatusMessage("Select an AI model to play.");
                updateGameStats(null);
                gameActive = false;
                resetGame();
                return;
            }

            currentModelFile = modelFile;
            updateStatusMessage(`Loading AI model: ${modelSelect.selectedOptions[0].text}...`);
            gameActive = false;

            try {
                aiModelSession = await InferenceSession.create(`models/${modelFile}`, { executionProviders: ['wasm'] });
                updateStatusMessage(`AI model loaded. ${humanStarts ? "Your turn." : "AI is thinking..."}`, humanStarts ? true : false);
                updateGameStats(currentModelFile);
                resetGame();
            } catch (error) {
                console.error("Failed to load ONNX model:", error);
                updateStatusMessage("Error loading AI model. Try another.");
                aiModelSession = null;
                currentModelFile = null;
                updateGameStats(null);
                gameActive = false;
                resetGame();
            }
        }

        function initializeBoardDOM() {
            boardContainer.innerHTML = '';
            boardContainer.style.gridTemplateColumns = `repeat(${COLUMNS}, 1fr)`;
            boardContainer.style.width = `${COLUMNS * CELL_SIZE}px`;
            boardContainer.style.height = `${ROWS * CELL_SIZE}px`;

            for (let c = 0; c < COLUMNS; c++) {
                const columnDiv = document.createElement('div');
                columnDiv.classList.add('column-hover-area');
                columnDiv.dataset.column = c;
                columnDiv.addEventListener('click', () => handleColumnClick(c));

                for (let r = 0; r < ROWS; r++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('cell');
                    cellDiv.id = `cell-${r}-${c}`;
                    cellDiv.style.width = `${CELL_SIZE}px`;
                    cellDiv.style.height = `${CELL_SIZE}px`;

                    const pieceDiv = document.createElement('div');
                    pieceDiv.classList.add('piece');
                    pieceDiv.style.width = `${CELL_SIZE * PIECE_RADIUS_RATIO}px`;
                    pieceDiv.style.height = `${CELL_SIZE * PIECE_RADIUS_RATIO}px`;
                    
                    cellDiv.appendChild(pieceDiv);
                    columnDiv.appendChild(cellDiv);
                }
                boardContainer.appendChild(columnDiv);
            }
        }

        function renderBoard() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLUMNS; c++) {
                    const pieceDiv = document.getElementById(`cell-${r}-${c}`).querySelector('.piece');
                    pieceDiv.classList.remove('player1', 'player2');
                    if (board[r][c] === HUMAN_PLAYER) {
                        pieceDiv.classList.add('player1');
                    } else if (board[r][c] === AI_PLAYER) {
                        pieceDiv.classList.add('player2');
                    }
                }
            }
        }

        function resetGame() {
            board = Array(ROWS).fill(null).map(() => Array(COLUMNS).fill(0));
            currentPlayer = humanStarts ? HUMAN_PLAYER : AI_PLAYER;
            gameActive = aiModelSession ? true : false;
            
            renderBoard();

            if (!aiModelSession) {
                updateStatusMessage(humanStarts ? "Select a model. Player starts." : "Select a model. AI will start.");
                return;
            }
            
            updateStatusMessage(humanStarts ? "Your turn" : "AI's turn. Thinking...", humanStarts ? true : false);
            updateGameStats(currentModelFile);

            if (currentPlayer === AI_PLAYER && gameActive) {
                setTimeout(aiMove, 500);
            }
        }

        function handleColumnClick(col) {
            if (!gameActive || currentPlayer !== HUMAN_PLAYER || !aiModelSession) return;

            if (isValidAction(col)) {
                makeMove(col, HUMAN_PLAYER);
            } else {
                updateStatusMessage("Invalid move. Column is full.");
                setTimeout(() => {
                    if (gameActive && currentPlayer === HUMAN_PLAYER) {
                        updateStatusMessage("Your turn", true);
                    }
                }, 1500);
            }
        }

        function makeMove(col, player) {
            if (!gameActive) return;

            for (let r = 0; r < ROWS; r++) {
                if (board[r][col] === 0) {
                    board[r][col] = player;
                    renderBoard();

                    if (checkWin(r, col, player)) {
                        endGame(player);
                        return;
                    }
                    if (isBoardFull()) {
                        endGame(0);
                        return;
                    }

                    switchPlayer();
                    return;
                }
            }
            console.error("makeMove called on a full column. This indicates a logic error.", col);
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === HUMAN_PLAYER) ? AI_PLAYER : HUMAN_PLAYER;
            updateStatusMessage((currentPlayer === HUMAN_PLAYER) ? "Your turn" : "AI's turn. Thinking...", currentPlayer === HUMAN_PLAYER);
            if (currentPlayer === AI_PLAYER && gameActive) {
                setTimeout(aiMove, 500);
            }
        }

        function isValidAction(col) {
            return board[ROWS - 1][col] === 0;
        }

        function getLegalActions() {
            const legal = [];
            for (let c = 0; c < COLUMNS; c++) {
                if (isValidAction(c)) {
                    legal.push(c);
                }
            }
            return legal;
        }

        function checkWin(r_played, c_played, player) {
            const directions = [
                { dr: 0, dc: 1 },
                { dr: 1, dc: 0 },
                { dr: 1, dc: 1 },
                { dr: 1, dc: -1 }
            ];

            for (const { dr, dc } of directions) {
                let count = 1;

                for (let i = 1; i < CONNECT_N; i++) {
                    const r = r_played + i * dr;
                    const c = c_played + i * dc;
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLUMNS && board[r][c] === player) {
                        count++;
                    } else {
                        break;
                    }
                }

                for (let i = 1; i < CONNECT_N; i++) {
                    const r = r_played - i * dr;
                    const c = c_played - i * dc;
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLUMNS && board[r][c] === player) {
                        count++;
                    } else {
                        break;
                    }
                }

                if (count >= CONNECT_N) {
                    return true;
                }
            }
            return false;
        }

        function isBoardFull() {
            return board[ROWS - 1].every(cell => cell !== 0);
        }

        function endGame(winner) {
            gameActive = false;
            if (winner === HUMAN_PLAYER) {
                updateStatusMessage("Congratulations! You win!");
            } else if (winner === AI_PLAYER) {
                updateStatusMessage("AI wins! Better luck next time.");
            } else {
                updateStatusMessage("It's a draw!");
            }
            if (currentModelFile) {
                incrementGameCount(currentModelFile);
            }
        }

        async function aiMove() {
            if (!gameActive || !aiModelSession || currentPlayer !== AI_PLAYER) return;

            const legalActions = getLegalActions();
            if (legalActions.length === 0) {
                if (isBoardFull()) endGame(0);
                return;
            }

            const boardForAI = board.map(row => row.map(cell => cell * AI_PLAYER)).flat();
            const tensorInput = new ort.Tensor('float32', Float32Array.from(boardForAI), [1, 1, ROWS, COLUMNS]);

            try {
                const feeds = { 'input_board': tensorInput };
                const results = await aiModelSession.run(feeds);
                const qValues = results.q_values.data;
                
                let bestAction = -1;
                let maxQ = -Infinity;

                for (const action of legalActions) {
                    if (qValues[action] > maxQ) {
                        maxQ = qValues[action];
                        bestAction = action;
                    }
                }
                
                if (bestAction !== -1 && isValidAction(bestAction)) {
                    makeMove(bestAction, AI_PLAYER);
                } else {
                    console.warn("AI couldn't find a valid best action, choosing random legal move. Q-Values:", qValues, "Legal Actions:", legalActions, "Chosen Best:", bestAction);
                    if (legalActions.length > 0) {
                         const randomAction = legalActions[Math.floor(Math.random() * legalActions.length)];
                         makeMove(randomAction, AI_PLAYER);
                    } else {
                        console.error("AI has no legal moves, but game should have ended (draw).");
                        if (isBoardFull()) endGame(0);
                    }
                }

            } catch (error) {
                console.error("Error during AI inference:", error);
                updateStatusMessage("AI error. Please try resetting. Choosing random move.");
                if (legalActions.length > 0) {
                    const randomAction = legalActions[Math.floor(Math.random() * legalActions.length)];
                    makeMove(randomAction, AI_PLAYER);
                }
            }
        }

        function getGameCounts() {
            const counts = localStorage.getItem('connect4AICounts');
            return counts ? JSON.parse(counts) : {};
        }

        function updateGameStats(modelFile) {
            if (!modelFile) {
                modelGamesPlayedSpan.textContent = 'N/A';
                return;
            }
            const counts = getGameCounts();
            modelGamesPlayedSpan.textContent = counts[modelFile] || 0;
        }

        function incrementGameCount(modelFile) {
            if (!modelFile) return;
            const counts = getGameCounts();
            counts[modelFile] = (counts[modelFile] || 0) + 1;
            localStorage.setItem('connect4AICounts', JSON.stringify(counts));
            updateGameStats(modelFile);
        }
    </script>
</body>
</html>